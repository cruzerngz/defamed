# defamed
<div align="center">

#### Default, named and positional function parameters.

[![crate](https://img.shields.io/crates/v/defamed.svg)](https://crates.io/crates/defamed)
[![docs](https://docs.rs/defamed/badge.svg)](https://docs.rs/defamed)
[![build status](https://github.com/cruzerngz/defamed/actions/workflows/tests.yml/badge.svg)](https://github.com/cruzerngz/defamed/actions/workflows/tests.yml)
</div>

## Quick start
Tag functions with `#[defamed::defamed]`, default parameters with `#[def]`
and use the generated macro with any combination of positional and named parameters.
```rust
#[defamed::defamed]
fn complex_function(
    lhs: i32,
    rhs: i32,
    // literals can be used as default values
    #[def(true)] add: bool,
    // if no default value is provided, the type must implement Default
    #[def] divide_result_by: Option<i32>,
) -> i32 {
    let intermediate = if add { lhs + rhs } else { lhs - rhs };

    match divide_result_by {
        Some(div) => intermediate / div,
        None => intermediate,
    }
}

assert_eq!(10, complex_function!(5, 5));
assert_eq!(10, complex_function!(rhs = 5, lhs = 15, add = false));
assert_eq!(5, complex_function!(5, 5, divide_result_by = Some(2)));
```

## Features
- Named and positional parameters in any order Ã  la [Python](https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions)
- Generated macros live in the same path as the function
- No runtime overhead

## Similar crates
#### [named](https://docs.rs/named)
- locally scoped macros only
#### [default_args](https://docs.rs/default_args)
- accepts python-like syntax in function signature
- may cause code clutter
#### [optargs](https://docs.rs/optargs)
- infers optional parameters that use the Option type
- struct builder macro

<!-- ## Introduction
Python allows users to call functions with named and default parameters.

<details>

<summary>Python example</summary>

```py
# this function
def some_function(
    sign: bool,
    value: int,
    add: int = 0,
    div: int = 1
) -> int:
    if sign:
        return (value + add) / div
    else:
        return (0 - value + add) / div

# can be used like this:
assert some_function(True, 10) == 10
assert some_function(value = 20, sign = False, div = 2) == -10
assert some_function(True, 10, add = -10) == 0
```

</details>

This macro generates a function macro that accepts positional and named parameters.
Parameters tagged with default values can be omitted.

```rust
// this function
#[defamed::defamed]
fn some_function(
    sign: bool,
    value: i32,
    // for types that implement std::default::Default
    #[def]
    add: i32,
    // any const expression can be a default
    #[def(2 + 1 - 2)]
    div: i32
) -> i32 {
    if sign {
        value + add
    } else {
        0 - value + add
    } / div
}

// can then be used like:
assert!(some_function!(true, 10) == 10);
assert!(some_function!(value = 20, sign = false, div = 2) == -10);
assert!(some_function!(true, 10, add = -10) == 0);
``` -->

## Parameter passing
The macro accepts parameters in any permutation as long as the following conditions are met:
- positional parameters order follows the original function signature
- all positional parameters are passed first
- named parameters come after all positional parameters
- named parameters can be included in any order
- default parameters are passed last
- default parameters can be excluded

<details>

<summary>Example</summary>

```rust
/// Add/sub 2 numbers, then take the absolute value, if applicable
#[defamed::defamed]
fn pos_and_def(
    lhs: i32,
    rhs: i32,
    #[def(true)]
    add: bool,
    #[def]
    abs_val: bool
) -> i32 {
    let inter = if add {lhs + rhs} else {lhs - rhs};
    if abs_val {inter.abs()} else {inter}
}

// original fn
assert_eq!(20, pos_and_def(5, 15, true, false));

// all positional
assert_eq!(20, pos_and_def!(5, 15, true, false));
// all named
assert_eq!(20, pos_and_def(lhs=5, rhs=15, add=true, abs_val=false));
// all named, in any order, defaults last
assert_eq!(20, pos_and_def(rhs=15, lhs=5, abs_val=false, add=true));
// defaults excluded
assert_eq!(20, pos_and_def!(5, 15));
// defaults excluded, positional in any order
assert_eq!(20, pos_and_def!(rhs=15, lhs=5));
// some positional, some named
assert_eq!(20, pos_and_def!(5, rhs=15));

// overriding first default parameter as positional
assert_eq!(20, pos_and_def!(25, 5, false));
// overriding second default parameter as named
assert_eq!(20, pos_and_def!(5, -25, abs_val=true));
```

</details>

## Macro scope
Macros generated by `defamed` can be exported and used by other crates if the path to the underlying function is public.

### Private
For functions that are used in the same module as they are defined, the macro resolves the call directly.
```rust
#[defamed::defamed]
fn local_scope() {}
// macro resolves to:
local_scope!() => local_scope()
```

When private functions are used inside child modules, the module path relative to the crate root needs to be provided.
```rust
#[defamed::defamed(crate)]
fn top_level_local_scope() {}

mod inner_consumer {
    fn inner() {
        super::top_level_local_scope!()
    }
}
```

### Public or Restricted
Functions with non-private visibility are called with their corresponding fully qualified path relative to the crate root.
The macro will require the module path to the function relative to the crate root.

For functions defined in the crate root, use `crate` as a path instead.
These macros can be used inside or imported by other crates as the macro [substitutes metavariables](https://doc.rust-lang.org/reference/macros-by-example.html#hygiene).

```rust
// public vis in root scope
#[defamed::defamed(crate)]
pub fn root_scope() {}

pub mod inner {
    // restricted vis in module `inner`
    #[defamed::defamed(inner)]
    pub(crate) fn crate_scope() {}
}

// macros resolve to:
crate_scope!() => $crate::inner::crate_scope()
root_scope() => $crate::root_scope()
```

## Benefits
- Better ergonomics
- More clarity during code reviews
- Seamless addition of default parameters to existing functions without breaking compatibility

## Limitations
- works only for standalone functions defined outside of an `impl` block
- requires specifying fully qualified module path to function
- renaming function parameters requires updating all macro invocations

<!-- ## Notes 4 me
- Determine macro invocation semantics
    - no DSL (function macros only)
    - attr macro w/ pseudo helper-attrs
- Determine param permutations a-la Python
- Exporting macro in module (! @ crate root) based on visibility:
    - main issue: https://github.com/rust-lang/rust/issues/59368
    - fix: https://github.com/rust-lang/rust/pull/108241
    - rust-analyzer hinting has issues
- Problem when invoking macro from extern module/crate
    - similar crates do not export macro with function (named, etc..)
    - inner function requires fully qualified path
    - attempt 1: module_path!() macro
        - macro needs to expand after insertion in attributed code
        - parse &str from compiler builtin macro
        - macros evaluate lazily -> outer macro receives ItemMacro tokens
        - possible, but requires nightly
    - other attempts:
        - caller_modpath: https://docs.rs/caller_modpath/latest/caller_modpath/
            - also requires nightly
        - eager: https://docs.rs/eager/latest/eager/macro.eager.html
            - does not expand builtin macro
    - crate name eval can be done at compile time using proc-macros
        - evaluate "CARGO_PKG_NAME" env var inside macro

- Current (temp) solution: define crate path path as a parameter in attribute

- New (iffy) solution: multi stage macros
    - this solution requires that this library is also included by the user in their crate (double import)
    - first proc-macro generates actual function macro with all permutations and exports function macro under module scope
    - when called, function macro resolves to another proc-macro to eval crate root path (crate:: or otherwise). this proc-macro is provided by this crate, hence the need to double import
    - final function substituted in code

- New (less iffy solution): more macro permutations!
    - every macro permutation now has 2 variants: a crate-wide invocation and a public invocation.
    - any macro not called in the same scope as it was defined will need the fully qualified path of it's invoked inner function
    - a `crate:` prefix indicates that the macro substitutes code for invocation inside it's own crate
    - no prefix indicates that code should be substituted for users of that crate -->
